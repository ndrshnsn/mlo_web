const u={logger:typeof console<"u"?console:void 0,WebSocket:typeof WebSocket<"u"?WebSocket:void 0},i={log(...n){this.enabled&&(n.push(Date.now()),u.logger.log("[ActionCable]",...n))}},h=()=>new Date().getTime(),l=n=>(h()-n)/1e3;class d{constructor(t){this.visibilityDidChange=this.visibilityDidChange.bind(this),this.connection=t,this.reconnectAttempts=0}start(){this.isRunning()||(this.startedAt=h(),delete this.stoppedAt,this.startPolling(),addEventListener("visibilitychange",this.visibilityDidChange),i.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`))}stop(){this.isRunning()&&(this.stoppedAt=h(),this.stopPolling(),removeEventListener("visibilitychange",this.visibilityDidChange),i.log("ConnectionMonitor stopped"))}isRunning(){return this.startedAt&&!this.stoppedAt}recordPing(){this.pingedAt=h()}recordConnect(){this.reconnectAttempts=0,this.recordPing(),delete this.disconnectedAt,i.log("ConnectionMonitor recorded connect")}recordDisconnect(){this.disconnectedAt=h(),i.log("ConnectionMonitor recorded disconnect")}startPolling(){this.stopPolling(),this.poll()}stopPolling(){clearTimeout(this.pollTimeout)}poll(){this.pollTimeout=setTimeout(()=>{this.reconnectIfStale(),this.poll()},this.getPollInterval())}getPollInterval(){const{staleThreshold:t,reconnectionBackoffRate:e}=this.constructor,s=Math.pow(1+e,Math.min(this.reconnectAttempts,10)),r=(this.reconnectAttempts===0?1:e)*Math.random();return t*1e3*s*(1+r)}reconnectIfStale(){this.connectionIsStale()&&(i.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${l(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`),this.reconnectAttempts++,this.disconnectedRecently()?i.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${l(this.disconnectedAt)} s`):(i.log("ConnectionMonitor reopening"),this.connection.reopen()))}get refreshedAt(){return this.pingedAt?this.pingedAt:this.startedAt}connectionIsStale(){return l(this.refreshedAt)>this.constructor.staleThreshold}disconnectedRecently(){return this.disconnectedAt&&l(this.disconnectedAt)<this.constructor.staleThreshold}visibilityDidChange(){document.visibilityState==="visible"&&setTimeout(()=>{(this.connectionIsStale()||!this.connection.isOpen())&&(i.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`),this.connection.reopen())},200)}}d.staleThreshold=6;d.reconnectionBackoffRate=.15;const g={message_types:{welcome:"welcome",disconnect:"disconnect",ping:"ping",confirmation:"confirm_subscription",rejection:"reject_subscription"},disconnect_reasons:{unauthorized:"unauthorized",invalid_request:"invalid_request",server_restart:"server_restart",remote:"remote"},default_mount_path:"/cable",protocols:["actioncable-v1-json","actioncable-unsupported"]},{message_types:c,protocols:a}=g,b=a.slice(0,a.length-1),f=[].indexOf;class p{constructor(t){this.open=this.open.bind(this),this.consumer=t,this.subscriptions=this.consumer.subscriptions,this.monitor=new d(this),this.disconnected=!0}send(t){return this.isOpen()?(this.webSocket.send(JSON.stringify(t)),!0):!1}open(){if(this.isActive())return i.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`),!1;{const t=[...a,...this.consumer.subprotocols||[]];return i.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${t}`),this.webSocket&&this.uninstallEventHandlers(),this.webSocket=new u.WebSocket(this.consumer.url,t),this.installEventHandlers(),this.monitor.start(),!0}}close({allowReconnect:t}={allowReconnect:!0}){if(t||this.monitor.stop(),this.isOpen())return this.webSocket.close()}reopen(){if(i.log(`Reopening WebSocket, current state is ${this.getState()}`),this.isActive())try{return this.close()}catch(t){i.log("Failed to reopen WebSocket",t)}finally{i.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`),setTimeout(this.open,this.constructor.reopenDelay)}else return this.open()}getProtocol(){if(this.webSocket)return this.webSocket.protocol}isOpen(){return this.isState("open")}isActive(){return this.isState("open","connecting")}triedToReconnect(){return this.monitor.reconnectAttempts>0}isProtocolSupported(){return f.call(b,this.getProtocol())>=0}isState(...t){return f.call(t,this.getState())>=0}getState(){if(this.webSocket){for(let t in u.WebSocket)if(u.WebSocket[t]===this.webSocket.readyState)return t.toLowerCase()}return null}installEventHandlers(){for(let t in this.events){const e=this.events[t].bind(this);this.webSocket[`on${t}`]=e}}uninstallEventHandlers(){for(let t in this.events)this.webSocket[`on${t}`]=function(){}}}p.reopenDelay=500;p.prototype.events={message(n){if(!this.isProtocolSupported())return;const{identifier:t,message:e,reason:s,reconnect:o,type:r}=JSON.parse(n.data);switch(r){case c.welcome:return this.triedToReconnect()&&(this.reconnectAttempted=!0),this.monitor.recordConnect(),this.subscriptions.reload();case c.disconnect:return i.log(`Disconnecting. Reason: ${s}`),this.close({allowReconnect:o});case c.ping:return this.monitor.recordPing();case c.confirmation:return this.subscriptions.confirmSubscription(t),this.reconnectAttempted?(this.reconnectAttempted=!1,this.subscriptions.notify(t,"connected",{reconnected:!0})):this.subscriptions.notify(t,"connected",{reconnected:!1});case c.rejection:return this.subscriptions.reject(t);default:return this.subscriptions.notify(t,"received",e)}},open(){if(i.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`),this.disconnected=!1,!this.isProtocolSupported())return i.log("Protocol is unsupported. Stopping monitor and disconnecting."),this.close({allowReconnect:!1})},close(n){if(i.log("WebSocket onclose event"),!this.disconnected)return this.disconnected=!0,this.monitor.recordDisconnect(),this.subscriptions.notifyAll("disconnected",{willAttemptReconnect:this.monitor.isRunning()})},error(){i.log("WebSocket onerror event")}};const m=function(n,t){if(t!=null)for(let e in t){const s=t[e];n[e]=s}return n};class S{constructor(t,e={},s){this.consumer=t,this.identifier=JSON.stringify(e),m(this,s)}perform(t,e={}){return e.action=t,this.send(e)}send(t){return this.consumer.send({command:"message",identifier:this.identifier,data:JSON.stringify(t)})}unsubscribe(){return this.consumer.subscriptions.remove(this)}}class y{constructor(t){this.subscriptions=t,this.pendingSubscriptions=[]}guarantee(t){this.pendingSubscriptions.indexOf(t)==-1?(i.log(`SubscriptionGuarantor guaranteeing ${t.identifier}`),this.pendingSubscriptions.push(t)):i.log(`SubscriptionGuarantor already guaranteeing ${t.identifier}`),this.startGuaranteeing()}forget(t){i.log(`SubscriptionGuarantor forgetting ${t.identifier}`),this.pendingSubscriptions=this.pendingSubscriptions.filter(e=>e!==t)}startGuaranteeing(){this.stopGuaranteeing(),this.retrySubscribing()}stopGuaranteeing(){clearTimeout(this.retryTimeout)}retrySubscribing(){this.retryTimeout=setTimeout(()=>{this.subscriptions&&typeof this.subscriptions.subscribe=="function"&&this.pendingSubscriptions.map(t=>{i.log(`SubscriptionGuarantor resubscribing ${t.identifier}`),this.subscriptions.subscribe(t)})},500)}}class v{constructor(t){this.consumer=t,this.guarantor=new y(this),this.subscriptions=[]}create(t,e){const s=t,o=typeof s=="object"?s:{channel:s},r=new S(this.consumer,o,e);return this.add(r)}add(t){return this.subscriptions.push(t),this.consumer.ensureActiveConnection(),this.notify(t,"initialized"),this.subscribe(t),t}remove(t){return this.forget(t),this.findAll(t.identifier).length||this.sendCommand(t,"unsubscribe"),t}reject(t){return this.findAll(t).map(e=>(this.forget(e),this.notify(e,"rejected"),e))}forget(t){return this.guarantor.forget(t),this.subscriptions=this.subscriptions.filter(e=>e!==t),t}findAll(t){return this.subscriptions.filter(e=>e.identifier===t)}reload(){return this.subscriptions.map(t=>this.subscribe(t))}notifyAll(t,...e){return this.subscriptions.map(s=>this.notify(s,t,...e))}notify(t,e,...s){let o;return typeof t=="string"?o=this.findAll(t):o=[t],o.map(r=>typeof r[e]=="function"?r[e](...s):void 0)}subscribe(t){this.sendCommand(t,"subscribe")&&this.guarantor.guarantee(t)}confirmSubscription(t){i.log(`Subscription confirmed ${t}`),this.findAll(t).map(e=>this.guarantor.forget(e))}sendCommand(t,e){const{identifier:s}=t;return this.consumer.send({command:e,identifier:s})}}class A{constructor(t){this._url=t,this.subscriptions=new v(this),this.connection=new p(this),this.subprotocols=[]}get url(){return w(this._url)}send(t){return this.connection.send(t)}connect(){return this.connection.open()}disconnect(){return this.connection.close({allowReconnect:!1})}ensureActiveConnection(){if(!this.connection.isActive())return this.connection.open()}addSubProtocol(t){this.subprotocols=[...this.subprotocols,t]}}function w(n){if(typeof n=="function"&&(n=n()),n&&!/^wss?:/i.test(n)){const t=document.createElement("a");return t.href=n,t.href=t.href,t.protocol=t.protocol.replace("http","ws"),t.href}else return n}function C(n=k("url")||g.default_mount_path){return new A(n)}function k(n){const t=document.head.querySelector(`meta[name='action-cable-${n}']`);if(t)return t.getAttribute("content")}export{p as Connection,d as ConnectionMonitor,A as Consumer,g as INTERNAL,S as Subscription,y as SubscriptionGuarantor,v as Subscriptions,u as adapters,C as createConsumer,w as createWebSocketURL,k as getConfig,i as logger};
//# sourceMappingURL=index-FRQGQGEM.js.map
