{"version":3,"file":"index-FRQGQGEM.js","sources":["../../../node_modules/@rails/actioncable/src/adapters.js","../../../node_modules/@rails/actioncable/src/logger.js","../../../node_modules/@rails/actioncable/src/connection_monitor.js","../../../node_modules/@rails/actioncable/src/internal.js","../../../node_modules/@rails/actioncable/src/connection.js","../../../node_modules/@rails/actioncable/src/subscription.js","../../../node_modules/@rails/actioncable/src/subscription_guarantor.js","../../../node_modules/@rails/actioncable/src/subscriptions.js","../../../node_modules/@rails/actioncable/src/consumer.js","../../../node_modules/@rails/actioncable/src/index.js"],"sourcesContent":["export default {\n  logger: typeof console !== \"undefined\" ? console : undefined,\n  WebSocket: typeof WebSocket !== \"undefined\" ? WebSocket : undefined,\n}\n","import adapters from \"./adapters\"\n\n// The logger is disabled by default. You can enable it with:\n//\n//   ActionCable.logger.enabled = true\n//\n//   Example:\n//\n//   import * as ActionCable from '@rails/actioncable'\n//\n//   ActionCable.logger.enabled = true\n//   ActionCable.logger.log('Connection Established.')\n//\n\nexport default {\n  log(...messages) {\n    if (this.enabled) {\n      messages.push(Date.now())\n      adapters.logger.log(\"[ActionCable]\", ...messages)\n    }\n  },\n}\n","import logger from \"./logger\"\n\n// Responsible for ensuring the cable connection is in good health by validating the heartbeat pings sent from the server, and attempting\n// revival reconnections if things go astray. Internal class, not intended for direct user manipulation.\n\nconst now = () => new Date().getTime()\n\nconst secondsSince = time => (now() - time) / 1000\n\nclass ConnectionMonitor {\n  constructor(connection) {\n    this.visibilityDidChange = this.visibilityDidChange.bind(this)\n    this.connection = connection\n    this.reconnectAttempts = 0\n  }\n\n  start() {\n    if (!this.isRunning()) {\n      this.startedAt = now()\n      delete this.stoppedAt\n      this.startPolling()\n      addEventListener(\"visibilitychange\", this.visibilityDidChange)\n      logger.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`)\n    }\n  }\n\n  stop() {\n    if (this.isRunning()) {\n      this.stoppedAt = now()\n      this.stopPolling()\n      removeEventListener(\"visibilitychange\", this.visibilityDidChange)\n      logger.log(\"ConnectionMonitor stopped\")\n    }\n  }\n\n  isRunning() {\n    return this.startedAt && !this.stoppedAt\n  }\n\n  recordPing() {\n    this.pingedAt = now()\n  }\n\n  recordConnect() {\n    this.reconnectAttempts = 0\n    this.recordPing()\n    delete this.disconnectedAt\n    logger.log(\"ConnectionMonitor recorded connect\")\n  }\n\n  recordDisconnect() {\n    this.disconnectedAt = now()\n    logger.log(\"ConnectionMonitor recorded disconnect\")\n  }\n\n  // Private\n\n  startPolling() {\n    this.stopPolling()\n    this.poll()\n  }\n\n  stopPolling() {\n    clearTimeout(this.pollTimeout)\n  }\n\n  poll() {\n    this.pollTimeout = setTimeout(() => {\n      this.reconnectIfStale()\n      this.poll()\n    }\n    , this.getPollInterval())\n  }\n\n  getPollInterval() {\n    const { staleThreshold, reconnectionBackoffRate } = this.constructor\n    const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10))\n    const jitterMax = this.reconnectAttempts === 0 ? 1.0 : reconnectionBackoffRate\n    const jitter = jitterMax * Math.random()\n    return staleThreshold * 1000 * backoff * (1 + jitter)\n  }\n\n  reconnectIfStale() {\n    if (this.connectionIsStale()) {\n      logger.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`)\n      this.reconnectAttempts++\n      if (this.disconnectedRecently()) {\n        logger.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`)\n      } else {\n        logger.log(\"ConnectionMonitor reopening\")\n        this.connection.reopen()\n      }\n    }\n  }\n\n  get refreshedAt() {\n    return this.pingedAt ? this.pingedAt : this.startedAt\n  }\n\n  connectionIsStale() {\n    return secondsSince(this.refreshedAt) > this.constructor.staleThreshold\n  }\n\n  disconnectedRecently() {\n    return this.disconnectedAt && (secondsSince(this.disconnectedAt) < this.constructor.staleThreshold)\n  }\n\n  visibilityDidChange() {\n    if (document.visibilityState === \"visible\") {\n      setTimeout(() => {\n        if (this.connectionIsStale() || !this.connection.isOpen()) {\n          logger.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`)\n          this.connection.reopen()\n        }\n      }\n      , 200)\n    }\n  }\n\n}\n\nConnectionMonitor.staleThreshold = 6 // Server::Connections::BEAT_INTERVAL * 2 (missed two pings)\nConnectionMonitor.reconnectionBackoffRate = 0.15\n\nexport default ConnectionMonitor\n","export default {\n  \"message_types\": {\n    \"welcome\": \"welcome\",\n    \"disconnect\": \"disconnect\",\n    \"ping\": \"ping\",\n    \"confirmation\": \"confirm_subscription\",\n    \"rejection\": \"reject_subscription\"\n  },\n  \"disconnect_reasons\": {\n    \"unauthorized\": \"unauthorized\",\n    \"invalid_request\": \"invalid_request\",\n    \"server_restart\": \"server_restart\",\n    \"remote\": \"remote\"\n  },\n  \"default_mount_path\": \"/cable\",\n  \"protocols\": [\n    \"actioncable-v1-json\",\n    \"actioncable-unsupported\"\n  ]\n}\n","import adapters from \"./adapters\"\nimport ConnectionMonitor from \"./connection_monitor\"\nimport INTERNAL from \"./internal\"\nimport logger from \"./logger\"\n\n// Encapsulate the cable connection held by the consumer. This is an internal class not intended for direct user manipulation.\n\nconst {message_types, protocols} = INTERNAL\nconst supportedProtocols = protocols.slice(0, protocols.length - 1)\n\nconst indexOf = [].indexOf\n\nclass Connection {\n  constructor(consumer) {\n    this.open = this.open.bind(this)\n    this.consumer = consumer\n    this.subscriptions = this.consumer.subscriptions\n    this.monitor = new ConnectionMonitor(this)\n    this.disconnected = true\n  }\n\n  send(data) {\n    if (this.isOpen()) {\n      this.webSocket.send(JSON.stringify(data))\n      return true\n    } else {\n      return false\n    }\n  }\n\n  open() {\n    if (this.isActive()) {\n      logger.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`)\n      return false\n    } else {\n      const socketProtocols = [...protocols, ...this.consumer.subprotocols || []]\n      logger.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${socketProtocols}`)\n      if (this.webSocket) { this.uninstallEventHandlers() }\n      this.webSocket = new adapters.WebSocket(this.consumer.url, socketProtocols)\n      this.installEventHandlers()\n      this.monitor.start()\n      return true\n    }\n  }\n\n  close({allowReconnect} = {allowReconnect: true}) {\n    if (!allowReconnect) { this.monitor.stop() }\n    // Avoid closing websockets in a \"connecting\" state due to Safari 15.1+ bug. See: https://github.com/rails/rails/issues/43835#issuecomment-1002288478\n    if (this.isOpen()) {\n      return this.webSocket.close()\n    }\n  }\n\n  reopen() {\n    logger.log(`Reopening WebSocket, current state is ${this.getState()}`)\n    if (this.isActive()) {\n      try {\n        return this.close()\n      } catch (error) {\n        logger.log(\"Failed to reopen WebSocket\", error)\n      }\n      finally {\n        logger.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`)\n        setTimeout(this.open, this.constructor.reopenDelay)\n      }\n    } else {\n      return this.open()\n    }\n  }\n\n  getProtocol() {\n    if (this.webSocket) {\n      return this.webSocket.protocol\n    }\n  }\n\n  isOpen() {\n    return this.isState(\"open\")\n  }\n\n  isActive() {\n    return this.isState(\"open\", \"connecting\")\n  }\n\n  triedToReconnect() {\n    return this.monitor.reconnectAttempts > 0\n  }\n\n  // Private\n\n  isProtocolSupported() {\n    return indexOf.call(supportedProtocols, this.getProtocol()) >= 0\n  }\n\n  isState(...states) {\n    return indexOf.call(states, this.getState()) >= 0\n  }\n\n  getState() {\n    if (this.webSocket) {\n      for (let state in adapters.WebSocket) {\n        if (adapters.WebSocket[state] === this.webSocket.readyState) {\n          return state.toLowerCase()\n        }\n      }\n    }\n    return null\n  }\n\n  installEventHandlers() {\n    for (let eventName in this.events) {\n      const handler = this.events[eventName].bind(this)\n      this.webSocket[`on${eventName}`] = handler\n    }\n  }\n\n  uninstallEventHandlers() {\n    for (let eventName in this.events) {\n      this.webSocket[`on${eventName}`] = function() {}\n    }\n  }\n\n}\n\nConnection.reopenDelay = 500\n\nConnection.prototype.events = {\n  message(event) {\n    if (!this.isProtocolSupported()) { return }\n    const {identifier, message, reason, reconnect, type} = JSON.parse(event.data)\n    switch (type) {\n      case message_types.welcome:\n        if (this.triedToReconnect()) {\n          this.reconnectAttempted = true\n        }\n        this.monitor.recordConnect()\n        return this.subscriptions.reload()\n      case message_types.disconnect:\n        logger.log(`Disconnecting. Reason: ${reason}`)\n        return this.close({allowReconnect: reconnect})\n      case message_types.ping:\n        return this.monitor.recordPing()\n      case message_types.confirmation:\n        this.subscriptions.confirmSubscription(identifier)\n        if (this.reconnectAttempted) {\n          this.reconnectAttempted = false\n          return this.subscriptions.notify(identifier, \"connected\", {reconnected: true})\n        } else {\n          return this.subscriptions.notify(identifier, \"connected\", {reconnected: false})\n        }\n      case message_types.rejection:\n        return this.subscriptions.reject(identifier)\n      default:\n        return this.subscriptions.notify(identifier, \"received\", message)\n    }\n  },\n\n  open() {\n    logger.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`)\n    this.disconnected = false\n    if (!this.isProtocolSupported()) {\n      logger.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\")\n      return this.close({allowReconnect: false})\n    }\n  },\n\n  close(event) {\n    logger.log(\"WebSocket onclose event\")\n    if (this.disconnected) { return }\n    this.disconnected = true\n    this.monitor.recordDisconnect()\n    return this.subscriptions.notifyAll(\"disconnected\", {willAttemptReconnect: this.monitor.isRunning()})\n  },\n\n  error() {\n    logger.log(\"WebSocket onerror event\")\n  }\n}\n\nexport default Connection\n","// A new subscription is created through the ActionCable.Subscriptions instance available on the consumer.\n// It provides a number of callbacks and a method for calling remote procedure calls on the corresponding\n// Channel instance on the server side.\n//\n// An example demonstrates the basic functionality:\n//\n//   App.appearance = App.cable.subscriptions.create(\"AppearanceChannel\", {\n//     connected() {\n//       // Called once the subscription has been successfully completed\n//     },\n//\n//     disconnected({ willAttemptReconnect: boolean }) {\n//       // Called when the client has disconnected with the server.\n//       // The object will have an `willAttemptReconnect` property which\n//       // says whether the client has the intention of attempting\n//       // to reconnect.\n//     },\n//\n//     appear() {\n//       this.perform('appear', {appearing_on: this.appearingOn()})\n//     },\n//\n//     away() {\n//       this.perform('away')\n//     },\n//\n//     appearingOn() {\n//       $('main').data('appearing-on')\n//     }\n//   })\n//\n// The methods #appear and #away forward their intent to the remote AppearanceChannel instance on the server\n// by calling the `perform` method with the first parameter being the action (which maps to AppearanceChannel#appear/away).\n// The second parameter is a hash that'll get JSON encoded and made available on the server in the data parameter.\n//\n// This is how the server component would look:\n//\n//   class AppearanceChannel < ApplicationActionCable::Channel\n//     def subscribed\n//       current_user.appear\n//     end\n//\n//     def unsubscribed\n//       current_user.disappear\n//     end\n//\n//     def appear(data)\n//       current_user.appear on: data['appearing_on']\n//     end\n//\n//     def away\n//       current_user.away\n//     end\n//   end\n//\n// The \"AppearanceChannel\" name is automatically mapped between the client-side subscription creation and the server-side Ruby class name.\n// The AppearanceChannel#appear/away public methods are exposed automatically to client-side invocation through the perform method.\n\nconst extend = function(object, properties) {\n  if (properties != null) {\n    for (let key in properties) {\n      const value = properties[key]\n      object[key] = value\n    }\n  }\n  return object\n}\n\nexport default class Subscription {\n  constructor(consumer, params = {}, mixin) {\n    this.consumer = consumer\n    this.identifier = JSON.stringify(params)\n    extend(this, mixin)\n  }\n\n  // Perform a channel action with the optional data passed as an attribute\n  perform(action, data = {}) {\n    data.action = action\n    return this.send(data)\n  }\n\n  send(data) {\n    return this.consumer.send({command: \"message\", identifier: this.identifier, data: JSON.stringify(data)})\n  }\n\n  unsubscribe() {\n    return this.consumer.subscriptions.remove(this)\n  }\n}\n","import logger from \"./logger\"\n\n// Responsible for ensuring channel subscribe command is confirmed, retrying until confirmation is received.\n// Internal class, not intended for direct user manipulation.\n\nclass SubscriptionGuarantor {\n  constructor(subscriptions) {\n    this.subscriptions = subscriptions\n    this.pendingSubscriptions = []\n  }\n\n  guarantee(subscription) {\n    if(this.pendingSubscriptions.indexOf(subscription) == -1){ \n      logger.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`)\n      this.pendingSubscriptions.push(subscription) \n    }\n    else {\n      logger.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`)\n    }\n    this.startGuaranteeing()\n  }\n\n  forget(subscription) {\n    logger.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`)\n    this.pendingSubscriptions = (this.pendingSubscriptions.filter((s) => s !== subscription))\n  }\n\n  startGuaranteeing() {\n    this.stopGuaranteeing()\n    this.retrySubscribing()\n  }\n  \n  stopGuaranteeing() {\n    clearTimeout(this.retryTimeout)\n  }\n\n  retrySubscribing() {\n    this.retryTimeout = setTimeout(() => {\n      if (this.subscriptions && typeof(this.subscriptions.subscribe) === \"function\") {\n        this.pendingSubscriptions.map((subscription) => {\n          logger.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`)\n          this.subscriptions.subscribe(subscription)\n        })\n      }\n    }\n    , 500)\n  }\n}\n\nexport default SubscriptionGuarantor","import Subscription from \"./subscription\"\nimport SubscriptionGuarantor from \"./subscription_guarantor\"\nimport logger from \"./logger\"\n\n// Collection class for creating (and internally managing) channel subscriptions.\n// The only method intended to be triggered by the user is ActionCable.Subscriptions#create,\n// and it should be called through the consumer like so:\n//\n//   App = {}\n//   App.cable = ActionCable.createConsumer(\"ws://example.com/accounts/1\")\n//   App.appearance = App.cable.subscriptions.create(\"AppearanceChannel\")\n//\n// For more details on how you'd configure an actual channel subscription, see ActionCable.Subscription.\n\nexport default class Subscriptions {\n  constructor(consumer) {\n    this.consumer = consumer\n    this.guarantor = new SubscriptionGuarantor(this)\n    this.subscriptions = []\n  }\n\n  create(channelName, mixin) {\n    const channel = channelName\n    const params = typeof channel === \"object\" ? channel : {channel}\n    const subscription = new Subscription(this.consumer, params, mixin)\n    return this.add(subscription)\n  }\n\n  // Private\n\n  add(subscription) {\n    this.subscriptions.push(subscription)\n    this.consumer.ensureActiveConnection()\n    this.notify(subscription, \"initialized\")\n    this.subscribe(subscription)\n    return subscription\n  }\n\n  remove(subscription) {\n    this.forget(subscription)\n    if (!this.findAll(subscription.identifier).length) {\n      this.sendCommand(subscription, \"unsubscribe\")\n    }\n    return subscription\n  }\n\n  reject(identifier) {\n    return this.findAll(identifier).map((subscription) => {\n      this.forget(subscription)\n      this.notify(subscription, \"rejected\")\n      return subscription\n    })\n  }\n\n  forget(subscription) {\n    this.guarantor.forget(subscription)\n    this.subscriptions = (this.subscriptions.filter((s) => s !== subscription))\n    return subscription\n  }\n\n  findAll(identifier) {\n    return this.subscriptions.filter((s) => s.identifier === identifier)\n  }\n\n  reload() {\n    return this.subscriptions.map((subscription) =>\n      this.subscribe(subscription))\n  }\n\n  notifyAll(callbackName, ...args) {\n    return this.subscriptions.map((subscription) =>\n      this.notify(subscription, callbackName, ...args))\n  }\n\n  notify(subscription, callbackName, ...args) {\n    let subscriptions\n    if (typeof subscription === \"string\") {\n      subscriptions = this.findAll(subscription)\n    } else {\n      subscriptions = [subscription]\n    }\n\n    return subscriptions.map((subscription) =>\n      (typeof subscription[callbackName] === \"function\" ? subscription[callbackName](...args) : undefined))\n  }\n\n  subscribe(subscription) {\n    if (this.sendCommand(subscription, \"subscribe\")) {\n      this.guarantor.guarantee(subscription)\n    }\n  }\n\n  confirmSubscription(identifier) {\n    logger.log(`Subscription confirmed ${identifier}`)\n    this.findAll(identifier).map((subscription) =>\n      this.guarantor.forget(subscription))\n  }\n\n  sendCommand(subscription, command) {\n    const {identifier} = subscription\n    return this.consumer.send({command, identifier})\n  }\n}\n","import Connection from \"./connection\"\nimport Subscriptions from \"./subscriptions\"\n\n// The ActionCable.Consumer establishes the connection to a server-side Ruby Connection object. Once established,\n// the ActionCable.ConnectionMonitor will ensure that its properly maintained through heartbeats and checking for stale updates.\n// The Consumer instance is also the gateway to establishing subscriptions to desired channels through the #createSubscription\n// method.\n//\n// The following example shows how this can be set up:\n//\n//   App = {}\n//   App.cable = ActionCable.createConsumer(\"ws://example.com/accounts/1\")\n//   App.appearance = App.cable.subscriptions.create(\"AppearanceChannel\")\n//\n// For more details on how you'd configure an actual channel subscription, see ActionCable.Subscription.\n//\n// When a consumer is created, it automatically connects with the server.\n//\n// To disconnect from the server, call\n//\n//   App.cable.disconnect()\n//\n// and to restart the connection:\n//\n//   App.cable.connect()\n//\n// Any channel subscriptions which existed prior to disconnecting will\n// automatically resubscribe.\n\nexport default class Consumer {\n  constructor(url) {\n    this._url = url\n    this.subscriptions = new Subscriptions(this)\n    this.connection = new Connection(this)\n    this.subprotocols = []\n  }\n\n  get url() {\n    return createWebSocketURL(this._url)\n  }\n\n  send(data) {\n    return this.connection.send(data)\n  }\n\n  connect() {\n    return this.connection.open()\n  }\n\n  disconnect() {\n    return this.connection.close({allowReconnect: false})\n  }\n\n  ensureActiveConnection() {\n    if (!this.connection.isActive()) {\n      return this.connection.open()\n    }\n  }\n\n  addSubProtocol(subprotocol) {\n    this.subprotocols = [...this.subprotocols, subprotocol]\n  }\n}\n\nexport function createWebSocketURL(url) {\n  if (typeof url === \"function\") {\n    url = url()\n  }\n\n  if (url && !/^wss?:/i.test(url)) {\n    const a = document.createElement(\"a\")\n    a.href = url\n    // Fix populating Location properties in IE. Otherwise, protocol will be blank.\n    a.href = a.href\n    a.protocol = a.protocol.replace(\"http\", \"ws\")\n    return a.href\n  } else {\n    return url\n  }\n}\n","import Connection from \"./connection\"\nimport ConnectionMonitor from \"./connection_monitor\"\nimport Consumer, { createWebSocketURL } from \"./consumer\"\nimport INTERNAL from \"./internal\"\nimport Subscription from \"./subscription\"\nimport Subscriptions from \"./subscriptions\"\nimport SubscriptionGuarantor from \"./subscription_guarantor\"\nimport adapters from \"./adapters\"\nimport logger from \"./logger\"\n\nexport {\n  Connection,\n  ConnectionMonitor,\n  Consumer,\n  INTERNAL,\n  Subscription,\n  Subscriptions,\n  SubscriptionGuarantor,\n  adapters,\n  createWebSocketURL,\n  logger,\n}\n\nexport function createConsumer(url = getConfig(\"url\") || INTERNAL.default_mount_path) {\n  return new Consumer(url)\n}\n\nexport function getConfig(name) {\n  const element = document.head.querySelector(`meta[name='action-cable-${name}']`)\n  if (element) {\n    return element.getAttribute(\"content\")\n  }\n}\n"],"names":["adapters","logger","messages","now","secondsSince","time","ConnectionMonitor","connection","staleThreshold","reconnectionBackoffRate","backoff","jitter","INTERNAL","message_types","protocols","supportedProtocols","indexOf","Connection","consumer","data","socketProtocols","allowReconnect","error","states","state","eventName","handler","event","identifier","message","reason","reconnect","type","extend","object","properties","key","value","Subscription","params","mixin","action","SubscriptionGuarantor","subscriptions","subscription","s","Subscriptions","channelName","channel","callbackName","args","command","Consumer","url","createWebSocketURL","subprotocol","a","createConsumer","getConfig","name","element"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9]}